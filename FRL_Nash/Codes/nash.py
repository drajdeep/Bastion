# -*- coding: utf-8 -*-
"""Bastion

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SLIAwoiZmWwFR3QRO9wuIz-cCZ-gjW2H
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

df = pd.read_csv("/content/Monday-WorkingHours.pcap_ISCX.csv")

np.random.seed(42)

# Adjusted Global Parameters for Nash Bargaining
epsilon_total = 10.0        # Total privacy budget
N = 10                      # Number of clients
T = 100                     # Maximum negotiation rounds
alpha = 0.1               # Step size for budget updates (smaller for gradual updates)
convergence_threshold = 1e-4  # Convergence threshold (stricter, to ensure minimal changes)

# Initialize budgets uniformly
epsilon = np.ones(N) * (epsilon_total / N)

def partition_data(df, num_clients):
    """
    Partition the DataFrame among num_clients by splitting rows.
    You can customize this to stratify or partition by certain columns.
    """
    partitions = np.array_split(df, num_clients)
    return partitions

def compute_client_characteristics(partitions):
    """
    For each client partition, compute:
      - data_size: number of records
      - data_quality: user-defined metric (placeholder)
      - sensitivity: user-defined metric (placeholder)
      - disagreement_point: minimal acceptable utility
    Customize these calculations based on your dataset's columns.
    """
    data_sizes = []
    data_qualities = []
    sensitivities = []
    disagreement_points = []

    for part in partitions:
        size = len(part)
        data_sizes.append(size)

        # Example data_quality: fraction of "clean" or "benign" rows, or any domain-specific measure
        # If your dataset doesn't have a "Label" column, adapt accordingly
        if 'Label' in part.columns:
            # Example: proportion of rows labeled "BENIGN"
            benign_ratio = np.mean(part['Label'] == "BENIGN")
            quality = benign_ratio
        else:
            # Fallback: treat all data as equally "good"
            quality = 0.5

        data_qualities.append(quality)

        # Example sensitivity: standard deviation of a numeric column
        # Replace "Flow Duration" with a column from your dataset
        if 'Flow Duration' in part.columns:
            sens = part['Flow Duration'].std()
            if np.isnan(sens) or sens <= 0:
                sens = 1.0
        else:
            # Fallback if no numeric column is available
            sens = 1.0

        sensitivities.append(sens)

        # Disagreement point: e.g., 10% of a hypothetical max utility
        # Adjust based on domain knowledge
        U_star_val = 0.1 * (quality * np.sqrt(size) * (1 - np.exp(-1.0 / sens)))
        disagreement_points.append(U_star_val)

    return (np.array(data_sizes),
            np.array(data_qualities),
            np.array(sensitivities),
            np.array(disagreement_points))

def utility(eps, q, d, s):
    """
    Utility function: U(ε) = q * sqrt(d) * (1 - exp(-ε / s)).
    Modify as needed for your domain-specific definition of utility.
    """
    return q * np.sqrt(d) * (1 - np.exp(-eps / s))

def jains_fairness(budgets):
    """Compute Jain's fairness index over the budget vector."""
    sum_x = np.sum(budgets)
    sum_x_sq = np.sum(budgets**2)
    return (sum_x**2) / (len(budgets) * sum_x_sq)







import numpy as np
import pandas as pd

# Load dataset
df = pd.read_csv("/content/Monday-WorkingHours.pcap_ISCX.csv")

# Parameters
N = 5  # Number of clients
T = 20  # Max negotiation rounds
alpha = 0.1  # Learning rate
epsilon_total = 5.0  # Total privacy budget
convergence_threshold = 1e-6  # Convergence criterion

# Partition data among N clients
partitions = partition_data(df, N)

# Compute client characteristics
data_sizes, data_qualities, sensitivities, disagreement_points = compute_client_characteristics(partitions)

# Initialize privacy budgets randomly to introduce variation
epsilon = np.random.uniform(0.1, 1.5, N)
epsilon = epsilon * (epsilon_total / np.sum(epsilon))  # Normalize

# Lists to store negotiation metrics
budget_history = []
nash_history = []
fairness_history = []

# Nash Bargaining Loop
for t in range(T):
    # Compute utility for each client
    utilities = np.array([
        utility(epsilon[k], data_qualities[k], data_sizes[k], sensitivities[k])
        for k in range(N)
    ])

    # Effective utility = utility - disagreement point
    effective_utils = np.maximum(utilities - disagreement_points, 1e-6)
    nash_product = np.prod(effective_utils)

    # Store metrics
    budget_history.append(epsilon.copy())
    nash_history.append(nash_product)
    fairness_history.append(jains_fairness(epsilon))

    # Compute surplus for redistribution
    surplus_total = np.sum(utilities - disagreement_points)

    # Update budgets with perturbation
    new_epsilon = np.zeros_like(epsilon)
    for k in range(N):
        desired = (utilities[k] - disagreement_points[k]) / (surplus_total + 1e-6) * epsilon_total
        perturbation = np.random.uniform(-0.02, 0.02)  # Small randomness
        new_epsilon[k] = epsilon[k] + alpha * (desired - epsilon[k]) + perturbation

    # Normalize to maintain global budget constraint
    new_epsilon = np.clip(new_epsilon, 0.1, 2.0)  # Ensure valid range
    new_epsilon = new_epsilon * (epsilon_total / np.sum(new_epsilon))

    # Convergence check
    if np.max(np.abs(new_epsilon - epsilon)) < convergence_threshold:
        epsilon = new_epsilon
        budget_history.append(epsilon.copy())

        # Recompute final metrics
        utilities = np.array([
            utility(epsilon[k], data_qualities[k], data_sizes[k], sensitivities[k])
            for k in range(N)
        ])
        effective_utils = np.maximum(utilities - disagreement_points, 1e-6)
        nash_product = np.prod(effective_utils)
        nash_history.append(nash_product)
        fairness_history.append(jains_fairness(epsilon))

        print(f"Converged at round {t+1}")
        break

    epsilon = new_epsilon

# Final results
print("Final Nash Product:", nash_history[-1])
print("Final Jain's Fairness Index:", fairness_history[-1])

# --- Visualization Code ---

# 1. Nash Product Convergence
plt.figure(figsize=(10, 6))
plt.plot(nash_history, marker='o', linestyle='-', color='blue')
plt.xlabel('Negotiation Round')
plt.ylabel('Nash Product')
plt.title('Nash Product Convergence Over Rounds')
plt.grid(True, linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# 2. Fairness Index Convergence (Jain's Fairness)
plt.figure(figsize=(10, 6))
plt.plot(fairness_history, marker='s', linestyle='-', color='orange')
plt.xlabel('Negotiation Round')
plt.ylabel("Jain's Fairness Index")
plt.title("Jain's Fairness Index Convergence Over Rounds")
plt.grid(True, linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# 3. Final Budget Allocation Distribution (Bar Chart)
plt.figure(figsize=(10, 6))
client_indices = np.arange(N)
plt.bar(client_indices, epsilon, color='green', alpha=0.8)
plt.xlabel('Client Index')
plt.ylabel('Final Privacy Budget')
plt.title('Final Privacy Budget Allocation per Client')
plt.xticks(client_indices, [f"Client {i+1}" for i in range(N)])
plt.tight_layout()
plt.show()

# 4. Budget Evolution per Client (Line Plot for each client)
plt.figure(figsize=(12, 8))
budget_history_array = np.array(budget_history)  # Shape: (num_rounds, N)
rounds = np.arange(len(budget_history))
for client in range(N):
    plt.plot(rounds, budget_history_array[:, client], marker='o', label=f"Client {client+1}")
plt.xlabel('Negotiation Round')
plt.ylabel('Privacy Budget')
plt.title('Evolution of Privacy Budgets Over Negotiation Rounds')
plt.legend()
plt.grid(True, linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# 6. Final Results
print("Final Nash Bargaining Allocations (privacy budgets):", epsilon)
print("Final Nash Product:", nash_product)
print("Final Jain's Fairness Index:", jains_fairness(epsilon))

print(nash_history)
print(fairness_history)

print("Rounds recorded in nash_history:", len(nash_history))
print("Rounds recorded in fairness_history:", len(fairness_history))

